<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="vitalije.20190708073913.1"><vh>@clean README.md</vh></v>
<v t="vitalije.20190708073255.1"><vh>project settings</vh>
<v t="vitalije.20190720151151.1"><vh>@settings</vh>
<v t="vitalije.20190720151217.1"><vh>@data extract-patterns</vh></v>
</v>
<v t="vitalije.20190709081959.1"><vh>Workspace</vh>
<v t="vitalije.20190709082121.1"><vh>@clean Cargo.toml</vh></v>
</v>
<v t="vitalije.20190708073246.1"><vh>@button n-save @key=Ctrl-s</vh>
<v t="vitalije.20190722085236.1"><vh>clean_uas_and_save_ref</vh></v>
<v t="vitalije.20190722085141.2"><vh>genbulma</vh></v>
<v t="vitalije.20190722085141.3"><vh>genpug</vh></v>
<v t="vitalije.20190722085141.4"><vh>process_one</vh></v>
<v t="vitalije.20190722085141.5"><vh>genvendor</vh></v>
<v t="vitalije.20190722085141.6"><vh>gencoffee</vh></v>
<v t="vitalije.20190722085656.1"><vh>ensure_target_web</vh></v>
</v>
<v t="vitalije.20190708073146.1"><vh>@clean .gitignore</vh></v>
</v>
<v t="vitalije.20190709160200.1"><vh>py-fossil-delta</vh>
<v t="vitalije.20190709083222.1"><vh>@clean py-fossil-delta/Cargo.toml</vh></v>
<v t="vitalije.20190709091253.1"><vh>@clean py-fossil-delta/python-extension-fossil-delta.md</vh></v>
<v t="vitalije.20190709083254.1"><vh>@clean py-fossil-delta/src/lib.rs</vh></v>
</v>
<v t="vitalije.20190709160215.1"><vh>fossil-delta</vh>
<v t="vitalije.20190708073324.1"><vh>@clean fossil-delta/Cargo.toml</vh></v>
<v t="vitalije.20190708073438.1"><vh>@clean fossil-delta/src/lib.rs</vh>
<v t="vitalije.20190708080758.1"><vh>b64 ints</vh>
<v t="vitalije.20190708080758.2"><vh>constants ...</vh></v>
<v t="vitalije.20190708090600.1"><vh>digit_count</vh></v>
<v t="vitalije.20190708091311.1"><vh>checksum</vh></v>
</v>
<v t="vitalije.20190708102546.1"><vh>generate_delta</vh>
<v t="vitalije.20190708103528.1"><vh>generate_delta - implementation</vh>
<v t="vitalije.20190708130411.1"><vh>0 - some utilities</vh>
<v t="vitalije.20190708131459.1"><vh>mb_backward</vh></v>
<v t="vitalije.20190708131503.1"><vh>mb_forward</vh></v>
</v>
<v t="vitalije.20190708105710.1"><vh>1 - write target length</vh></v>
<v t="vitalije.20190708105810.1"><vh>2 - check for small targets</vh></v>
<v t="vitalije.20190708110328.1"><vh>3 - compute the hash table</vh></v>
<v t="vitalije.20190708123712.1"><vh>4 - generate delta</vh></v>
<v t="vitalije.20190708134856.1"><vh>5 - tail</vh></v>
<v t="vitalije.20190708135156.1"><vh>6 - checksum record</vh></v>
</v>
</v>
<v t="vitalije.20190708180426.1"><vh>delta</vh></v>
<v t="vitalije.20190708102914.1"><vh>delta_output_size</vh></v>
<v t="vitalije.20190708183210.1"><vh>deltainv</vh></v>
<v t="vitalije.20190708083136.1"><vh>Hash</vh></v>
<v t="vitalije.20190708081957.1"><vh>LIBRARY TESTS</vh>
<v t="vitalije.20190708082017.1"><vh>b64_works</vh></v>
<v t="vitalije.20190708175842.1"><vh>test_hash_update</vh></v>
<v t="vitalije.20190708175831.1"><vh>delta_gen</vh></v>
<v t="vitalije.20190709214611.1"><vh>round_trip_test</vh></v>
<v t="vitalije.20190709214622.1"><vh>round_trip_test2</vh></v>
<v t="vitalije.20190711104435.1"><vh>empty_txt</vh></v>
<v t="vitalije.20190708190730.1"><vh>test_deltainv</vh></v>
<v t="vitalije.20190711122248.1"><vh>test_bug_001</vh></v>
<v t="vitalije.20190920132731.1"><vh>test_bug_002</vh></v>
<v t="vitalije.20190920125620.1"><vh>&lt;&lt;strings&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="vitalije.20190709160731.1"><vh>leo-ver-serv</vh>
<v t="vitalije.20190722085734.1"><vh>web leo-ver-serv</vh>
<v t="vitalije.20190722085928.1"><vh>get vendors</vh>
<v t="vitalije.20190722094440.1"><vh>extract_codemirror</vh></v>
</v>
<v t="vitalije.20190722085820.1"><vh>@vendor js/vendors.js</vh></v>
<v t="vitalije.20190722085751.1"><vh>@coffee js/app.js</vh>
<v t="vitalije.20190729154326.1"><vh>wait</vh></v>
<v t="vitalije.20190729173544.1"><vh>partition</vh></v>
<v t="vitalije.20190722130051.1"><vh>EVENTS</vh></v>
<v t="vitalije.20190722130334.1"><vh>dispatch...</vh></v>
<v t="vitalije.20190722122040.1"><vh>appstate</vh>
<v t="vitalije.20190722135155.1"><vh>currentIndex</vh></v>
<v t="vitalije.20190729173243.1"><vh>currentGnx</vh></v>
<v t="vitalije.20190722124355.1"><vh>range</vh></v>
<v t="vitalije.20190722130737.1"><vh>rev</vh></v>
<v t="vitalije.20190722124223.1"><vh>leoFiles</vh></v>
<v t="vitalije.20190722131709.1"><vh>outline</vh></v>
<v t="vitalije.20190722132007.1"><vh>topIndex</vh></v>
<v t="vitalije.20190722124256.1"><vh>currentFile</vh></v>
<v t="vitalije.20190722132321.1"><vh>topNode</vh></v>
</v>
<v t="vitalije.20190722130905.1"><vh>get_rev_count</vh></v>
<v t="vitalije.20190722130908.1"><vh>get_leo_files</vh>
<v t="vitalije.20190722141838.1"><vh>partition</vh></v>
</v>
<v t="vitalije.20190722151421.1"><vh>set_outline</vh></v>
<v t="vitalije.20190722151416.1"><vh>get_outline_rev</vh></v>
<v t="vitalije.20190722135552.1"><vh>drawTree</vh>
<v t="vitalije.20190722153239.1"><vh>visible_nodes</vh></v>
</v>
<v t="vitalije.20190722171734.1"><vh>get_body</vh></v>
<v t="vitalije.20190729171345.1"><vh>get_body_rev</vh></v>
<v t="vitalije.20190729172726.1"><vh>connect_outline_revisions</vh></v>
<v t="vitalije.20190729172738.1"><vh>connect_node_revisions</vh></v>
<v t="vitalije.20190928104916.1"><vh>connect_tree</vh></v>
<v t="vitalije.20190928151539.1"><vh>select_leo_file</vh></v>
<v t="vitalije.20190928151310.1"><vh>update_leo_files</vh></v>
<v t="vitalije.20190928112512.1"><vh>connect_file_selection</vh></v>
<v t="vitalije.20190928151405.1"><vh>install_editor</vh></v>
<v t="vitalije.20190722172447.1"><vh>start_app</vh></v>
</v>
<v t="vitalije.20190722085839.1"><vh>@bulma css/app.css</vh>
<v t="vitalije.20190722101835.1"><vh>.app-flex</vh></v>
<v t="vitalije.20190722102031.1"><vh>.no-show</vh></v>
</v>
<v t="vitalije.20190722085852.1"><vh>@pug index.html</vh>
<v t="vitalije.20190722090008.1"><vh>&lt;&lt;mixins&gt;&gt;</vh></v>
</v>
</v>
<v t="vitalije.20190709160748.1"><vh>@clean leo-ver-serv/src/main.rs</vh>
<v t="vitalije.20190928170916.1"><vh>AppState</vh></v>
<v t="vitalije.20190928170928.1"><vh>load_file</vh></v>
<v t="vitalije.20190928170932.1"><vh>load_valid_names</vh></v>
<v t="vitalije.20190720151032.1"><vh>st_file</vh></v>
<v t="vitalije.20190722072026.1"><vh>ensure_connection</vh>
<v t="vitalije.20190722071704.1"><vh>dbname</vh></v>
<v t="vitalije.20190722071708.1"><vh>make_connection</vh></v>
</v>
<v t="vitalije.20190720152015.1"><vh>post_snapshot</vh></v>
<v t="vitalije.20190722080218.1"><vh>post_node_at</vh></v>
<v t="vitalije.20190722080236.1"><vh>post_node_rev</vh></v>
<v t="vitalije.20190722081531.1"><vh>post_snapshot_rev</vh></v>
<v t="vitalije.20190722080629.1"><vh>post_node_rev_count</vh></v>
<v t="vitalije.20190722080222.1"><vh>post_snapshot_at</vh></v>
<v t="vitalije.20190720152022.1"><vh>index</vh></v>
<v t="vitalije.20190720152025.1"><vh>favicon</vh></v>
<v t="vitalije.20190722124627.1"><vh>get_leo_files</vh></v>
</v>
<v t="vitalije.20190720114956.1"><vh>@clean leo-ver-serv/src/db-sqlite.rs</vh>
<v t="vitalije.20190720144355.1"><vh>partition, rpartition</vh></v>
<v t="vitalije.20190721152644.1"><vh>decode_snapshot</vh></v>
<v t="vitalije.20190721154502.1"><vh>process_snapshot</vh></v>
<v t="vitalije.20190721154018.1"><vh>add_snapshot</vh></v>
<v t="vitalije.20190721200842.1"><vh>get_all_at</vh></v>
<v t="vitalije.20190721210558.1"><vh>get_all_revision</vh></v>
<v t="vitalije.20190721205405.1"><vh>get_node_at</vh></v>
<v t="vitalije.20190721210327.1"><vh>get_node_revision</vh></v>
<v t="vitalije.20190721203545.1"><vh>get_node_rev_count</vh></v>
<v t="vitalije.20190721154013.1"><vh>connect</vh></v>
<v t="vitalije.20190721154022.1"><vh>create_tables</vh></v>
</v>
<v t="vitalije.20190709160800.1"><vh>@clean leo-ver-serv/Cargo.toml</vh></v>
<v t="vitalije.20190730145718.1"><vh>@clean leo-ver-serv/README.md</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="vitalije.20190708073146.1">@nocolor
/target
**/*.rs.bk
Cargo.lock
fossil-delta.leo</t>
<t tx="vitalije.20190708073246.1">import requests
import json
import re
import os
at = c.atFileCommands
@others
c.save()
clean_uas_and_save_ref()
ensure_target_web()
for p in c.allNodes_iter():
    if p.h.startswith(('@bulma ', )):
        process_one(p, genbulma)
    elif p.h.startswith('@pug '):
        process_one(p, genpug)
    elif p.h.startswith('@vendor '):
        process_one(p, genvendor)
    elif p.h.startswith('@coffee '):
        process_one(p, gencoffee)
</t>
<t tx="vitalije.20190708073255.1">g.es(c.config.getData('extract-patterns')[-1])
</t>
<t tx="vitalije.20190708073324.1">@nocolor
[package]
name = "fossil-delta"
version = "0.2.0"
authors = ["vitalije &lt;vitalije@kviziracija.net&gt;"]
edition = "2018"
description = "Provides functions for calculating differences between strings and applying calculated deltas"
repository = "https://github.com/vitalije/fossil-delta.git"
readme = "../README.md"
license = "MIT"
keywords = ["diff", "text", "delta", "fossil", "VCS"]
categories = ["algorithms", "compression", "encoding", "text-processing"]
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</t>
<t tx="vitalije.20190708073438.1">@language rust
@tabwidth -4
/*! Implementation of the delta algorithm used by fossil version control system.

```rust
use fossil_delta::{delta, deltainv};
let a = b"line 1
  yet another (a bit longer) line 2
  yet another (a bit longer) line 3
  yet another (a bit longer) line 4
  yet another (a bit longer) line 5
  yet another (a bit longer) line 6
  yet another (a bit longer) line 7
  yet another (a bit longer) line 8
  yet another (a bit longer) line 9
  yet another (a bit longer) line 10";
let b = b"line 1
  yet another (a bit longer) line 2
  yet another (a bit longer) line 3
  yet another (a bit longer) line 4
  yet another (a bit longer) line 5
  yet another (a bit longer) line 6
  yet another (a bit longer) line 6 1/2
  yet another (a bit longer) line 7
  yet another (a bit longer) line 8
  yet another (a bit longer) line 9
  and finally last line 10";
let d = delta(a, b);
let s = deltainv(b, &amp;d);
assert_eq!(&amp;s, a);
assert_eq!(d.len(), 43);
```
*/

use std::convert::TryInto;

#[derive(Debug)]
pub enum Error {
    BadChecksum,
    CopyExceedsSize,
    CopyExtendsPasteEndOfInput,
    UnexpectedCharacter(u8),
}

const NHASH: usize = 16;
@others
</t>
<t tx="vitalije.20190708073913.1"># A Delta algorithm ported to Rust


This algorithm is used in [fossil](https://fossil-scm.org) where it has been implemented in C-99.
This crate contains the same algorithm implemented in Rust.

It exports two functions: `delta(a:&amp;str, b:&amp;str) -&gt; String` and `deltainv(b:&amp;str, d:&amp;str) -&gt; String`.

```
// creating delta between a and its next version b
let d = delta(a, b);

// applying delta to b to get previous version a
let s = deltainv(b, d);

assert_eq!(s, a);
```

Suppose we have some text value `a`, and user has changed it to value `b`. Using `delta`
function we can get a compressed delta value `d` that we can store and keep it along with
the new text value `b`. If later user wants to see the previous version of text,
we can use `deltainv(b, d)` to get the previous value `a`. If we keep all consequtive deltas
we can use `deltainv` multiple times to get any of the earlier text versions.

The delta value calculated between two utf-8 encoded strings is itself utf-8 encoded string.

The algorithm is very well described
[here](https://fossil-scm.org/home/doc/trunk/www/delta_encoder_algorithm.wiki) in the fossil wiki.

The code of this repository is best viewed in [Leo editor](https://leoeditor.com). The outline
containing the code is in a single outline file: [fossil-delta-ref.leo](fossil-delta-ref.leo).

This repository contains two more Rust crates, `py-fossil-delta` which exports fossil-delta
functions to Python as an extension module.

The third crate is `leo-ver-serv` which is a binary (executable) web server which accepts
snapshots from Leo, calculates the delta form the previous snapshot and stores all deltas
in a database. On the other side, this server serves a small web application which allows
user to browse history of known Leo files.

</t>
<t tx="vitalije.20190708080758.1">/// converts integer to String in base 64
pub fn b64str(n: u32) -&gt; String {
    if n == 0 {
        String::from("0")
    } else {
        let mut res = String::new();
        let mut _n = n;
        while _n &gt; 0 {
            res.insert(0, B64DIGITS[(_n &amp; 63) as usize]);
            _n = _n &gt;&gt; 6;
        }
        res
    }
}

/// converts base 64 str to u32
pub fn b64int&lt;T: AsRef&lt;[u8]&gt; + ?Sized&gt;(a: &amp;T) -&gt; u32 {
    b64int_read(a.as_ref()).0 as u32
}

pub fn b64int_read&lt;T: AsRef&lt;[u8]&gt; + ?Sized&gt;(a: &amp;T) -&gt; (usize, &amp;[u8]) {
    let mut res = 0_usize;
    for (j, i) in a.as_ref().iter().enumerate() {
        let k = B64VALUES[(i &amp; 127) as usize];
        if k == 255 {
             let a = a.as_ref();
            return (res, &amp;a[j..]);
        }
        res = (res &lt;&lt; 6) + (k as usize);
    }
    (res, b"")
}

</t>
<t tx="vitalije.20190708080758.2">const B64DIGITS: [char; 64] = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
    'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a',
    'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', '~',
];
const B64VALUES: [u8; 128] = [
    255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
    255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
    255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8,
    255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 0u8, 1u8, 2u8, 3u8, 4u8, 5u8,
    6u8, 7u8, 8u8, 9u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 10u8, 11u8, 12u8, 13u8,
    14u8, 15u8, 16u8, 17u8, 18u8, 19u8, 20u8, 21u8, 22u8, 23u8, 24u8, 25u8, 26u8, 27u8, 28u8, 29u8,
    30u8, 31u8, 32u8, 33u8, 34u8, 35u8, 255u8, 255u8, 255u8, 255u8, 36u8, 255u8, 37u8, 38u8, 39u8,
    40u8, 41u8, 42u8, 43u8, 44u8, 45u8, 46u8, 47u8, 48u8, 49u8, 50u8, 51u8, 52u8, 53u8, 54u8, 55u8,
    56u8, 57u8, 58u8, 59u8, 60u8, 61u8, 62u8, 255u8, 255u8, 255u8, 63u8, 255u8,
];

</t>
<t tx="vitalije.20190708081957.1">#[cfg(test)]
mod tests {
    use super::*;
    @others
&lt;&lt;strings&gt;&gt;
}
</t>
<t tx="vitalije.20190708082017.1">#[test]
fn b64_works() {
    for i in 0..1000 {
        let s = b64str(i);
        let s1 = b64str(i + 0x1_00_0000);
        assert_eq!(i, b64int(&amp;s));
        assert_eq!(i, b64int(&amp;s1) - 0x1_00_0000);
    }
}
</t>
<t tx="vitalije.20190708083136.1">const NHASH_1: usize = NHASH - 1;
const NHASHI32: i32 = NHASH as i32;
struct Hash {
    a: u16,
    b: u16,
    i: usize,
    z: [u8; NHASH],
}
impl Hash {
    fn new() -&gt; Self {
        Hash {
            a: 0,
            b: 0,
            i: 0,
            z: [0; NHASH],
        }
    }
    /// Initialize the rolling hash using the first NHASH characters of z[]
    fn init(&amp;mut self, z: &amp;[u8]) {
        let mut a = z[0] as u32;
        let mut b = z[0] as u32;
        self.z[0] = z[0];
        for i in 1..NHASH {
            a = (a + (z[i] as u32)) &amp; 0xffff;
            b = (b + a) &amp; 0xffff;
            self.z[i] = z[i];
        }
        self.a = a as u16;
        self.b = b as u16;
        self.i = 0;
    }
    /// Advance the rolling hash by a single character c
    fn update(&amp;mut self, c: u8) {
        let old = self.z[self.i];
        self.z[self.i] = c;
        self.i = (self.i + 1) &amp; NHASH_1;
        let a = (self.a as i32) + (c as i32) - (old as i32);
        let b = (self.b as i32) - NHASHI32 * (old as i32) + (a &amp; 0xffff);
        self.a = (a &amp; 0xffff) as u16;
        self.b = (b &amp; 0xffff) as u16;
    }
    /// Return a usize hash value
    fn as_usize(&amp;self) -&gt; usize {
        (self.a as usize) | ((self.b as usize) &lt;&lt; 16)
    }
}
</t>
<t tx="vitalije.20190708090600.1">/// Return the number digits in the base-64 representation of a positive integer
pub fn digit_count(v: usize) -&gt; usize {
    let mut x = 64;
    for i in 1..10 {
        if x &gt; v {
            return i;
        };
        x = x &lt;&lt; 6;
    }
    11
}

</t>
<t tx="vitalije.20190708091311.1">/// Compute a 32-bit big-endian checksum on the N-byte buffer.  If the
/// buffer is not a multiple of 4 bytes length, compute the sum that would
/// have occurred if the buffer was padded with zeros to the next multiple
/// of four bytes.
fn checksum&lt;T: AsRef&lt;[u8]&gt;&gt;(z_in: T) -&gt; u32 {
    let it = z_in.as_ref().chunks_exact(4);
    let b = it.remainder();
    let a_b: [u8; 4] = match b.len() {
        0 =&gt; [0, 0, 0, 0],
        1 =&gt; [b[0], 0, 0, 0],
        2 =&gt; [b[0], b[1], 0, 0],
        _ =&gt; [b[0], b[1], b[2], 0],
    };
    let mut s: u32 = u32::from_be_bytes(a_b);
    for b in it {
        let a_b: &amp;[u8; 4] = unsafe { &amp;*(b.as_ptr() as *const [u8; 4]) };
        let a = u32::from_be_bytes(*a_b);
        s = s.overflowing_add(a).0;
    }
    s
}
</t>
<t tx="vitalije.20190708102546.1">/// Generate new delta in given mutable string reference
///
/// ## Output Format:
///
/// The delta begins with a base64 number followed by a newline.  This
/// number is the number of bytes in the TARGET file.  Thus, given a
/// delta file z, a program can compute the size of the output file
/// simply by reading the first line and decoding the base-64 number
/// found there. The delta_output_size() routine does exactly this.
///
/// After the initial size number, the delta consists of a series of
/// literal text segments and commands to copy from the SOURCE file.
/// A copy command looks like this:
///
/// &lt;pre&gt;NNN@MMM,&lt;/pre&gt;
///
/// where `NNN` is the number of bytes to be copied and `MMM` is the offset
/// into the source file of the first byte (both base-64).   If `NNN` is 0
/// it means copy the rest of the input file.  Literal text is like this:
///
/// &lt;pre&gt;NNN:TTTTT&lt;/pre&gt;
///
/// where `NNN` is the number of bytes of text (base-64) and `TTTTT` is
/// the text.
/// The last term is of the form
///
/// &lt;pre&gt;NNN;&lt;/pre&gt;
///
/// In this case, `NNN` is a 32-bit bigendian checksum of the output file
/// that can be used to verify that the delta applied correctly.  All
/// numbers are in base-64.
///
/// Pure text files generate a pure text delta.  Binary files generate a
/// delta that may contain some binary data.
///
/// ## Algorithm:
///
/// The encoder first builds a hash table to help it find matching
/// patterns in the source file.  16-byte chunks of the source file
/// sampled at evenly spaced intervals are used to populate the hash
/// table.
///
/// Next we begin scanning the target file using a sliding 16-byte
/// window.  The hash of the 16-byte window in the target is used to
/// search for a matching section in the source file.  When a match
/// is found, a copy command is added to the delta.  An effort is
/// made to extend the matching section to regions that come before
/// and after the 16-byte hash window.  A copy command is only issued
/// if the result would use less space that just quoting the text
/// literally. Literal text is added to the delta for sections that
/// do not match or which can not be encoded efficiently using copy
/// commands.
///
</t>
<t tx="vitalije.20190708102914.1">/// Return the size (in bytes) of the output from applying
/// a delta.
///
/// This routine is provided so that an procedure that is able
/// to call delta_apply() can learn how much space is required
/// for the output and hence allocate nor more space that is really
/// needed.
///
pub fn delta_output_size&lt;T: AsRef&lt;[u8]&gt;&gt;(z_delta: T) -&gt; usize {
    b64int(&amp;z_delta) as usize
}

</t>
<t tx="vitalije.20190708103528.1">pub fn generate_delta&lt;T: AsRef&lt;[u8]&gt;, V: AsRef&lt;[u8]&gt;&gt;(
    z_out_t: T,         /* The target text */
    z_src_t: V,         /* The source text */
    z_delta: &amp;mut Vec&lt;u8&gt;, /* A string to hold the resulting delta */
) {
    z_delta.clear();
    let z_src = z_src_t.as_ref();
    @others
}

</t>
<t tx="vitalije.20190708105710.1">z_delta.extend_from_slice(b64str(z_out.len() as u32).as_bytes());
z_delta.push(b'\n');

</t>
<t tx="vitalije.20190708105810.1">/* If the source file is very small, it means that we have no
 ** chance of ever doing a copy command.  Just output a single
 ** literal segment for the entire target and exit.
 */
if z_src.len() &lt;= NHASH {
    z_delta.extend_from_slice(b64str(z_out.len() as u32).as_bytes());
    z_delta.push(b':');
    z_delta.extend_from_slice(z_out);
    z_delta.extend_from_slice(b64str(checksum(&amp;z_out)).as_bytes());
    z_delta.push(b';');
    return;
}
</t>
<t tx="vitalije.20190708110328.1">/* Compute the hash table used to locate matching sections in the
 ** source file.
 */
let n_hash = z_src.len() / NHASH;
let mut collide = vec![0xffff_ffff_u32; 2 * n_hash];
let mut h = Hash::new();
for i in 0..n_hash {
    h.init(&amp;z_src[(NHASH * i)..]);
    let hv = h.as_usize() % n_hash + n_hash;
    collide[i] = collide[hv];
    collide[hv] = i as u32;
}
</t>
<t tx="vitalije.20190708123712.1">let mut base = 0usize;
while base + NHASH &lt; z_out.len() {
    let mut i = 0;
    h.init(&amp;z_out[base..]);
    let mut best_count = 0;
    let mut best_offset = 0;
    let mut best_lit_size = 0;
    loop {
        let hv = h.as_usize() % n_hash;
        let mut i_block = collide[n_hash + hv];
        let mut limit = 250;
        while i_block != 0xffff_ffff &amp;&amp; limit &gt; 0 {
            limit -= 1;
            let i_src = (i_block as usize) * NHASH;
            if z_src[i_src] == z_out[base + i] {
                let j = mb_forward(i_src, base + i);
                let k = mb_backward(i_src, base + i, base);
                let ofst = i_src - k;
                let cnt = j + k + 1;
                let litsz = i - k;
                let sz = digit_count(litsz) + digit_count(cnt) + digit_count(ofst) + 3;
                if cnt &gt; sz &amp;&amp; cnt &gt; best_count {
                    best_count = cnt;
                    best_offset = ofst;
                    best_lit_size = litsz;
                }
            }
            i_block = collide[i_block as usize];
        }
        if best_count &gt; 0 {
            if best_lit_size &gt; 0 {
                z_delta.extend_from_slice(b64str(best_lit_size as u32).as_bytes());
                z_delta.push(b':');
                z_delta.extend_from_slice(&amp;z_out[base..(base + best_lit_size)]);
                base += best_lit_size;
            }
            base += best_count;
            z_delta.extend_from_slice(b64str(best_count as u32).as_bytes());
            z_delta.push(b'@');
            z_delta.extend_from_slice(b64str(best_offset as u32).as_bytes());
            z_delta.push(b',');
            break;
        } else if base + i + NHASH &gt;= z_out.len() {
            z_delta.extend_from_slice(b64str((z_out.len() - base) as u32).as_bytes());
            z_delta.push(b':');
            z_delta.extend_from_slice(&amp;z_out[base..]);
            base = z_out.len();
            break;
        } else {
            h.update(z_out[base + NHASH + i]);
            i += 1;
        }
    }
}
</t>
<t tx="vitalije.20190708130411.1"></t>
<t tx="vitalije.20190708131459.1">let z_out = z_out_t.as_ref();
// match block backward
let mb_backward = |i, j, n| {
    if i == 0 || j &lt;= n {
        return 0;
    }
    let mut k = i - 1;
    let mut m = j - 1;
    let n_1 = if n == 0 { 0 } else { n - 1 };
    while k &gt; 0 &amp;&amp; m &gt; n_1 {
        if z_src[k] != z_out[m] {
            return i - k - 1;
        }
        k -= 1;
        m -= 1;
    }
    i - k - 1
};
</t>
<t tx="vitalije.20190708131503.1">// match block forward
let mb_forward = |i, j| {
    let mut k = i + 1;
    let mut m = j + 1;
    while k &lt; z_src.len() &amp;&amp; m &lt; z_out.len() {
        if z_src[k] != z_out[m] {
            return k - i - 1;
        }
        k += 1;
        m += 1;
    }
    if z_src.len() - i &lt; z_out.len() - j {
        z_src.len() - i - 1
    } else {
        z_out.len() - j - 1
    }
};
</t>
<t tx="vitalije.20190708134856.1">if base &lt; z_out.len() {
    z_delta.extend_from_slice(b64str((z_out.len() - base) as u32).as_bytes());
    z_delta.push(b':');
    z_delta.extend_from_slice(&amp;z_out[base..]);
}
</t>
<t tx="vitalije.20190708135156.1">z_delta.extend_from_slice(b64str(checksum(z_out)).as_bytes());
z_delta.push(b';');
</t>
<t tx="vitalije.20190708175831.1">#[test]
fn delta_gen() {
    let old = include_str!("test-data/file-a.txt");
    let cur = include_str!("test-data/file-b.txt");
    let d1: &amp;[u8] = include_bytes!("test-data/file-delta.txt");
    let mut d = Vec::new();
    generate_delta(&amp;cur, &amp;old, &amp;mut d);
    assert_eq!(d.as_slice(), d1);
}
</t>
<t tx="vitalije.20190708175842.1">#[test]
fn test_hash_update() {
    let mut h = Hash::new();
    h.init(b"0123456789ABCDEFFEDCBA9876543210");
    assert_eq!(h.as_usize(), 0x1cbb03a2);
    let mut h2 = Hash::new();
    h2.init(b"123456789ABCDEFFEDCBA9876543210");
    h.update(b'F');
    assert_eq!(h.as_usize(), h2.as_usize())
}
</t>
<t tx="vitalije.20190708180426.1">/// Creates delta and returns it as a String
/// see [`generate_delta`]
pub fn delta&lt;T: AsRef&lt;[u8]&gt;, V: AsRef&lt;[u8]&gt;&gt;(a: T, b: V) -&gt; Vec&lt;u8&gt; {
    let mut d = Vec::with_capacity(b.as_ref().len() + 60);
    generate_delta(a, b, &amp;mut d);
    d
}

pub fn apply&lt;T: AsRef&lt;[u8]&gt;, V: AsRef&lt;[u8]&gt;&gt;(source: T, delta: V) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
    let source = source.as_ref();
    let mut total = 0;
    let source_length = source.len();
    let (total_length, mut delta) = b64int_read(&amp;delta);
    let mut output = Vec::with_capacity(total_length);

    delta = &amp;delta[1..];
    while delta.len() &gt; 0 {
        let (cnt, delta_read) = b64int_read(delta);
        match delta_read[0] {
            b'@' =&gt; {
                total += cnt;
                let (offset, delta_read) = b64int_read(&amp;delta_read[1..]);
                if total &gt; total_length {
                    return Err(Error::CopyExceedsSize);
                }
                if offset + cnt &gt; source_length {
                    return Err(Error::CopyExtendsPasteEndOfInput);
                }
                output.extend_from_slice(&amp;source[offset..(offset + cnt)]);
                delta = &amp;delta_read[1..];
            }
            b':'=&gt; {
                total += cnt;
                let i = delta.len() - delta_read.len() + 1;
                if total &gt; total_length {
                    return Err(Error::CopyExceedsSize);
                }
                output.extend_from_slice(&amp;delta[i..(cnt + i)]);
                delta = &amp;delta_read[(1 + cnt)..];
            }
            b';' =&gt; {
                if cnt != checksum(&amp;output).try_into().unwrap() {
                    return Err(Error::BadChecksum);
                }
                return Ok(output);
            }
            c =&gt; {
                return Err(Error::UnexpectedCharacter(c));
            }
        }
    }
    
    Ok(output)
}

</t>
<t tx="vitalije.20190708183210.1">/// Given the current version of text value `b_txt` and delta value as `d_txt`
/// this function returns the previous version of text b_txt.
pub fn deltainv&lt;T: AsRef&lt;[u8]&gt;, V: AsRef&lt;[u8]&gt;&gt;(b_txt: T, d_txt: V) -&gt; Vec&lt;u8&gt; {
    let (total_length, mut d_src) = b64int_read(&amp;d_txt);

    let mut a_res = Vec::with_capacity(total_length);
    let b_txt = b_txt.as_ref();
    let b_bytes = b_txt;
    let d_txt = d_txt.as_ref();
    d_src = &amp;d_src[1..];
    while d_src.len() &gt; 0 {
        let (cnt, d1_src) = b64int_read(d_src);
        match d1_src[0] {
            b'@' =&gt; {
                let (ofst, d1_src) = b64int_read(&amp;d1_src[1..]);
                a_res.extend_from_slice(&amp;b_bytes[ofst..(ofst + cnt)]);
                d_src = &amp;d1_src[1..];
            }
            b':' =&gt; {
                let i = d_txt.len() - d1_src.len() + 1;
                a_res.extend_from_slice(&amp;d_txt[i..(cnt + i)]);
                d_src = &amp;d1_src[(1 + cnt)..];
            }
            b';' =&gt; return a_res,
            _ =&gt; {
                let msg = format!(
                    r#"Error in applying delta
        txt: {:?}
        -----------------------------
        delta: {:?}
        =============================
        index: {}
        "#,
                    b_txt,
                    d_txt,
                    d_txt.len() - d1_src.len()
                );
                panic!("{}", msg)
            }
        }
    }
    a_res
}

</t>
<t tx="vitalije.20190708190730.1">#[test]
fn test_deltainv() {
    let old = include_bytes!("test-data/file-a.txt");
    let cur = include_bytes!("test-data/file-b.txt");
    let d1: &amp;[u8] = include_bytes!("test-data/file-delta.txt");
    let res = deltainv(cur, d1);
    assert_eq!(&amp;res[..30], &amp;old[..30]);
}
#[test] 
fn apply_test() {
    let old = include_str!("test-data/file-a.txt");
    let cur = include_str!("test-data/file-b.txt");
    let d1: &amp;[u8] = include_bytes!("test-data/file-delta.txt");
    let out = apply(&amp;old, &amp;d1).unwrap();
    assert_eq!(cur, String::from_utf8_lossy(&amp;out));
}
</t>
<t tx="vitalije.20190709081959.1"></t>
<t tx="vitalije.20190709082121.1">[workspace]

members = [
    "fossil-delta",
    "py-fossil-delta",
    "leo-ver-serv"
]</t>
<t tx="vitalije.20190709083222.1">[package]
name = "py-fossil-delta"
version = "0.1.2"
authors = ["vitalije &lt;vitalije@kviziracija.net&gt;"]
edition = "2018"
description = "Provides functions for calculating differences between strings and applying calculated deltas"
repository = "https://github.com/vitalije/fossil-delta.git"
readme = "python-extension-fossil-delta.md"
license = "MIT"
keywords = ["python", "diff", "text", "delta", "fossil"]
categories = ["algorithms", "compression", "encoding", "text-processing"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
name = "fossil_delta"
crate-type = ["cdylib"]

[build-dependencies]
cbindgen = "0.5.2"

[dependencies]
fossil-delta = { path="../fossil-delta", version="0.2.0"}

[dependencies.pyo3]
version = "0.8.4"
features = ["extension-module"]
</t>
<t tx="vitalije.20190709083254.1">use fossil_delta::{delta, deltainv};
use pyo3::prelude::*;

#[pymodule]
fn fossil_delta(_py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    /// Calculates delta between two given strings a and b
    ///
    /// &gt;&gt;&gt; d = fossil_delta.delta(a, b)
    /// &gt;&gt;&gt; s = fossil_delta.deltainv(b, d)
    /// &gt;&gt;&gt; assert s == a
    ///
    #[pyfn(m, "delta")]
    fn py_delta(py: Python, a: &amp;str, b: &amp;str) -&gt; PyResult&lt;PyObject&gt; {
        let res = delta(a, b);
        Ok(res.to_object(py))
    }
    /// Applies delta tp given text and returns changed text
    ///
    /// &gt;&gt;&gt; d = fossil_delta.delta(a, b)
    /// &gt;&gt;&gt; s = fossil_delta.deltainv(b, d)
    /// &gt;&gt;&gt; assert s == a
    ///
    #[pyfn(m, "deltainv")]
    fn py_deltainv(py: Python, b: &amp;str, d: PyObject) -&gt; PyResult&lt;String&gt; {
        let dv: Vec&lt;u8&gt; = d.extract(py).unwrap();
        String::from_utf8(deltainv(b, &amp;dv))
            .map_err(|e| e.into())
    }
    Ok(())
}
</t>
<t tx="vitalije.20190709091253.1"># fossil_delta a Python extension

This crate exports functions `fossil_delta::delta` and `fossil_delta::deltainv` to
Python interepreter. The resulting library built with:

```
cargo build --release
```
on Linux is named `libfossil_delta.so`. Before using in Python it has to be renamed
to `fossil_delta.so`. On Windows it should be probably renamed to `fossil_delta.pyd`
or `fossil_delta.dll`.

# Usage:

```
&gt;&gt;&gt; import fossil_delta
&gt;&gt;&gt; a = """line 1
... yet another (a bit longer) line 2
... yet another (a bit longer) line 3
... yet another (a bit longer) line 4
... yet another (a bit longer) line 5
... yet another (a bit longer) line 6
... yet another (a bit longer) line 7
... yet another (a bit longer) line 8
... yet another (a bit longer) line 9
... yet another (a bit longer) line 10"""
... 
&gt;&gt;&gt; b = """line 1
... yet another (a bit longer) line 2
... yet another (a bit longer) line 3
... yet another (a bit longer) line 4
... yet another (a bit longer) line 5
... yet another (a bit longer) line 6
... yet another (a bit longer) line 7
... yet another (a bit longer) line 8
... and finally last line 10
... yet another (a bit longer) line 9
... yet another (a bit longer) line 10"""
...
&gt;&gt;&gt; d = fossil_delta.delta(a, b)
&gt;&gt;&gt; s = fossil_delta.deltainv(b, d)
&gt;&gt;&gt; s == a
True
&gt;&gt;&gt;
```
</t>
<t tx="vitalije.20190709160200.1"></t>
<t tx="vitalije.20190709160215.1"></t>
<t tx="vitalije.20190709160731.1"></t>
<t tx="vitalije.20190709160748.1">@language rust
@tabwidth -4
#[path = "db-sqlite.rs"]
mod db;
#[cfg(debug_assertions)]
use actix_files::NamedFile;
#[cfg(debug_assertions)]
use actix_web::Result;
use actix_web::{http::StatusCode, web, App, HttpRequest, HttpResponse, HttpServer, Responder};
use chrono::NaiveDateTime;
use db::partition;
use serde::Serialize;
use std::cell::RefCell;
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::Read;
#[cfg(debug_assertions)]
use std::path::PathBuf;
@others
fn main() {
    let mut args = env::args();
    if args.len() &lt; 2 {
        println!("Usage:  leo-ver-serv &lt;valid-filenames&gt; &lt;port&gt;");
    } else {
        let port = args.nth(2).unwrap_or(String::from("8088"));
        HttpServer::new(|| {
            App::new()
                .data(AppState::new())
                .data(web::PayloadConfig::new(1 &lt;&lt; 25))
                .route("/", web::get().to(index))
                .route("/public/{filename:.*}", web::get().to(st_file))
                .route("/favicon.ico", web::get().to(favicon))
                .route("/add-snapshot", web::post().to(post_snapshot))
                .route("/snapshot-at", web::post().to(post_snapshot_at))
                .route("/node-at", web::post().to(post_node_at))
                .route("/node-rev", web::post().to(post_node_rev))
                .route("/node-rev-count", web::post().to(post_node_rev_count))
                .route("/snapshot-rev", web::post().to(post_snapshot_rev))
                .route("/leo-files", web::get().to(get_leo_files))
        })
        .bind(format!("127.0.0.1:{}", port))
        .unwrap()
        .run()
        .unwrap();
    }
}
</t>
<t tx="vitalije.20190709160800.1">[package]
name = "leo-ver-serv"
version = "0.1.8"
authors = ["vitalije &lt;vitalije@kviziracija.net&gt;"]
edition = "2018"
description = "A web server which accepts snapshots from Leo, and serves web application for browsing history of known Leo files."
repository = "https://github.com/vitalije/fossil-delta.git"
readme = "README.md"
license = "MIT"
keywords = ["web", "delta", "fossil", "VCS", "Leo"]
categories = ["command-line-utilities", "compression", "web-programming::http-server", "text-processing"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
actix-web = "1.0"
actix-files = "0.1.3"
chrono = "0.4.7"
fossil-delta = {version="0.2.0", path="../fossil-delta"}
serde = "1.0.97"
serde_json = "1.0.40"

[dependencies.rusqlite]
version = "0.19.0"
features = ["bundled"]
</t>
<t tx="vitalije.20190709214611.1">#[test]
fn round_trip_test() {
    let a = b"line 1
        yet another (a bit longer) line 2
        yet another (a bit longer) line 3
        yet another (a bit longer) line 4
        yet another (a bit longer) line 5
        yet another (a bit longer) line 6
        yet another (a bit longer) line 7
        yet another (a bit longer) line 8
        yet another (a bit longer) line 9
        yet another (a bit longer) line 10";
    let b = b"line 1
        yet another (a bit longer) line 2
        yet another (a bit longer) line 3
        yet another (a bit longer) line 4
        yet another (a bit longer) line 5
        yet another (a bit longer) line 6
        yet another (a bit longer) line 6 1/2
        yet another (a bit longer) line 7
        yet another (a bit longer) line 8
        yet another (a bit longer) line 9
        and finally last line 10";
    let d = delta(a, b);
    println!("delta:{:?}", &amp;d);
    let s = deltainv(b, &amp;d);
    assert_eq!(&amp;s, a);
    assert_eq!(d.len(), 43);
}
</t>
<t tx="vitalije.20190709214622.1">#[test]
fn round_trip_test2() {
    let a = r#"def do_Expression(self, node):\n    '''An inner expression'''\n    self.visit(node.body)\n"#.as_bytes();
    let b = r#"sion(self, node):\n    '''An inner expression'''\n    self.visit(node.body)\n"#.as_bytes();
    println!(
        "a.len={}, b.len={}, b64={}",
        a.len(),
        b.len(),
        &amp;b64str(a.len() as u32)
    );
    let d = delta(b, a);
    println!("delta:{:?}", &amp;d);
    let s = deltainv(a, &amp;d);
    assert_eq!(&amp;s, b);
}
</t>
<t tx="vitalije.20190711104435.1">#[test]
fn empty_txt() {
    let a = "".as_bytes();
    let b = r#"line 1
  yet another (a bit longer) line 2
  yet another (a bit longer) line 3
  yet another (a bit longer) line 4
  yet another (a bit longer) line 5
  yet another (a bit longer) line 6
  yet another (a bit longer) line 6 1/2
  yet another (a bit longer) line 7
  yet another (a bit longer) line 8
  yet another (a bit longer) line 9
  and finally last line 10"#.as_bytes();
    let d = delta(b, a);
    println!("empty delta:{:?}", &amp;d);
    let s = deltainv(a, &amp;d);
    assert_eq!(b, &amp;s);
}
</t>
<t tx="vitalije.20190711122248.1">#[test]
fn test_bug_001() {
    let a=b"send-snap\nimport zmq\n#c.user_dict.pop('sendsnap', None)\n@others\nmsg = \"snapshot %s\"% snap()\nsend(msg)\n#msg = \"getat 2019-07-11 10:06:21\"\n#res = send(msg, True)\n#with open('/tmp/proba', 'w') as out:\n#    out.write(res)\ng.es('ok')\n";
    let b=b"send-snap\nimport zmq\n#c.user_dict.pop('sendsnap', None)\n@others\nmsg = \"snapshot %s\"% snap()\n\nsend(msg)\n#msg = \"getat 2019-07-11 10:06:21\"\n#res = send(msg, True)\n#with open('/tmp/proba', 'w') as out:\n#    out.write(res)\ng.es('ok')\n";
    let d = b"3a\n1S@0,29@1T,31_Pqh;";
    let d1 = delta(&amp;a, &amp;b);
    assert_eq!(&amp;d1, &amp;d);
    let s = deltainv(b, &amp;d1);
    assert_eq!(&amp;s, a);
}
</t>
<t tx="vitalije.20190720114956.1">@language rust
@tabwidth -4
//use rusqlite::types::ToSql;
use chrono::NaiveDateTime;
use fossil_delta::{delta, deltainv};
pub use rusqlite::{params, Connection, Result, Statement, Transaction, NO_PARAMS};
use std::collections::HashMap;
@others
</t>
<t tx="vitalije.20190720144355.1">/* pub fn rpartition&lt;'a&gt;(input:&amp;'a str, sep:&amp;str) -&gt; (&amp;'a str, &amp;'a str, &amp;'a str) {
  match input.rfind(sep) {
    Some(i) =&gt; {
      let j = i + sep.len();
      (&amp;input[..i], &amp;input[i..j], &amp;input[j..])
    },
    None =&gt; {
      (&amp;input, "", "")
    }
  }
}
*/
pub fn partition&lt;'a&gt;(input: &amp;'a str, sep: &amp;str) -&gt; (&amp;'a str, &amp;'a str, &amp;'a str) {
    match input.find(sep) {
        Some(i) =&gt; {
            let j = i + sep.len();
            (&amp;input[..i], &amp;input[i..j], &amp;input[j..])
        }
        None =&gt; (&amp;input, "", ""),
    }
}
</t>
<t tx="vitalije.20190720151032.1">#[cfg(debug_assertions)]
fn st_file(req: HttpRequest) -&gt; Result&lt;NamedFile&gt; {
    let path: PathBuf = req.match_info().query("filename").parse().unwrap();
    let rpath = PathBuf::from("leo-ver-serv/web/").join(path);
    let file = NamedFile::open(rpath)?;
    Ok(file.use_last_modified(true).use_etag(true))
}
#[cfg(not(debug_assertions))]
static APPJS: &amp;str = include_str!("../web/js/app.js");

#[cfg(not(debug_assertions))]
static VENDORSJS: &amp;str = include_str!("../web/js/vendors.js");

#[cfg(not(debug_assertions))]
static APPCSS: &amp;str = include_str!("../web/css/app.css");

#[cfg(not(debug_assertions))]
static INDEXHTML: &amp;str = include_str!("../web/index.html");

#[cfg(not(debug_assertions))]
fn st_file(req: HttpRequest) -&gt; impl Responder {
    match req.match_info().query("filename") {
        "js/app.js" =&gt; HttpResponse::Ok()
            .content_type("application/javascript")
            .body(APPJS),
        "js/vendors.js" =&gt; HttpResponse::Ok()
            .content_type("application/javascript")
            .body(VENDORSJS),
        "css/app.css" =&gt; HttpResponse::Ok().content_type("text/css").body(APPCSS),
        "index.html" =&gt; HttpResponse::Ok().content_type("text/html").body(INDEXHTML),
        _ =&gt; HttpResponse::NotFound().finish(),
    }
}
</t>
<t tx="vitalije.20190720151151.1"></t>
<t tx="vitalije.20190720151217.1">^\s*(?:pub\s+)?fn\s+(\w+)\s*[(]
^\s*(?:pub\s+)?struct\s+(\w+)\s*[{]
^\s*(?:pub\s+)?impl\s+(\w+\s+for\s+\w+)\s*[{]
^\s*let\s+(?:mut\s+)?(\w+)\s*=\s*[|][^|]*[|]\s*(?:-&gt;|[{])</t>
<t tx="vitalije.20190720152015.1">fn post_snapshot(data: web::Data&lt;AppState&gt;, text: String) -&gt; &amp;'static str {
    let (fname, _, rest) = partition(&amp;text, "\n");
    let (t, sep, snapdata) = partition(rest, "\n");
    let ok = sep.len() &gt; 0;
    let ok = ok &amp;&amp; NaiveDateTime::parse_from_str(t, "%Y-%m-%dT%H:%M:%S%.f").is_ok();
    let ok = ok &amp;&amp; {
        let mut hmap = data.m.borrow_mut();
        if data.valid_names.lines().all(|x| x != fname) {
            return "Unknwon file";
        }
        ensure_connection(&amp;mut hmap, fname);
        let ok = match db::add_snapshot(hmap.get_mut(fname).unwrap(), t, snapdata) {
            Ok(a) =&gt; a,
            Err(e) =&gt; {
                println!("post_snapshot:{:?}", e);
                false
            }
        };
        ok
    };
    println!("post snapshot {} bytes at {}", snapdata.len(), t);
    if ok {
        "Ok"
    } else {
        "Err"
    }
}
</t>
<t tx="vitalije.20190720152022.1">fn index() -&gt; impl Responder {
    HttpResponse::Ok()
        .status(StatusCode::MOVED_PERMANENTLY)
        .set_header("Location", "/public/index.html")
        .finish()
}
</t>
<t tx="vitalije.20190720152025.1">static FICON: &amp;[u8] = include_bytes!("../favicon.ico");
fn favicon() -&gt; impl Responder {
    HttpResponse::Ok()
        .content_type("image/vnd.microsoft.icon")
        .body(FICON)
}
</t>
<t tx="vitalije.20190721152644.1">fn decode_snapshot(txt: &amp;str) -&gt; HashMap&lt;String, String&gt; {
    let (outline, _, rest) = partition(txt, "\n\n");
    let mut nodes = HashMap::new();
    nodes.insert(String::from("__outline__"), String::from(outline));
    let mut i = 0;
    let nrest = rest.len();
    while i &lt; nrest {
        let (n, _, x) = partition(&amp;rest[i..], " ");
        i += n.len() + 1;
        let n: usize = n.parse().unwrap();
        let (gnx, _, hb) = partition(&amp;x[..n], "\n");
        i += n;
        nodes.insert(String::from(gnx), String::from(hb));
    }
    nodes
}
</t>
<t tx="vitalije.20190721154013.1">pub fn connect(pth: &amp;str) -&gt; Result&lt;Connection&gt; {
    let conn = Connection::open(pth)?;
    create_tables(&amp;conn)?;
    Ok(conn)
}
</t>
<t tx="vitalije.20190721154018.1">pub fn add_snapshot(conn: &amp;mut Connection, tstamp: &amp;str, data: &amp;str) -&gt; Result&lt;bool&gt; {
    match NaiveDateTime::parse_from_str(tstamp, "%Y-%m-%dT%H:%M:%S%.f") {
        Ok(_) =&gt; {
            let tx = conn.transaction()?;
            // it used to be useful to keep all snapshots in case history needs to be rebuilt
            // but in production it would consume too much space to keep all raw snapshots in db
            // {
            //   let mut stmt = tx.prepare("replace into snapshots(t, data) values(?, ?)")?;
            //   stmt.execute(params![tstamp, data])?;
            // }
            process_snapshot(&amp;tx, tstamp, data)?;
            tx.commit()?;
            Ok(true)
        }
        _ =&gt; Ok(false),
    }
}</t>
<t tx="vitalije.20190721154022.1">fn create_tables(conn: &amp;Connection) -&gt; Result&lt;()&gt; {
    conn.execute(
        "create table if not exists snapshots(t primary key, data)",
        params![],
    )?;
    conn.execute(
        "create table if not exists present(gnx primary key, hb, x)",
        params![],
    )?;
    conn.execute(
        "create table if not exists changes(t, gnx, d, primary key (t, gnx))",
        params![],
    )?;
    conn.execute(
        "create index if not exists gnx_changes on changes(gnx)",
        params![],
    )?;
    Ok(())
}
</t>
<t tx="vitalije.20190721154502.1">fn process_snapshot(tx: &amp;Transaction, tstamp: &amp;str, txt: &amp;str) -&gt; Result&lt;()&gt; {
    let mut nodes = decode_snapshot(txt);
    let mut a = Vec::new();
    let mut b = Vec::new();
    let mut stmt = tx.prepare("select gnx, hb from present")?;
    let mut rows = stmt.query(NO_PARAMS)?;
    while let Ok(Some(row)) = rows.next() {
        let gnx: String = row.get(0).unwrap();
        let hb: String = row.get(1).unwrap();
        match nodes.remove(&amp;gnx) {
            Some(s) =&gt; {
                if hb != s {
                    a.push((tstamp, gnx.clone(), delta(&amp;hb, &amp;s)));
                    b.push((gnx, s, false));
                }
            }
            None =&gt; {
                // this node is deleted
                if hb.len() &gt; 0 {
                    a.push((tstamp, gnx.clone(), delta(&amp;hb, "")));
                }
                b.push((gnx, String::new(), true));
            }
        }
    }
    for (gnx, hb) in nodes.drain() {
        // these nodes are new
        a.push((tstamp, gnx.clone(), delta("", &amp;hb)));
        b.push((gnx, hb, false));
    }
    let mut stmt = tx.prepare("insert or replace into present(gnx, hb, x) values (?, ?, ?)")?;
    for (x, y, z) in b {
        stmt.execute(params![x, y, z])?;
    }
    let mut stmt = tx.prepare("insert into changes(t, gnx, d) values (?, ?, ?)")?;
    for (x, y, z) in a {
        stmt.execute(params![x, y, z])?;
    }
    Ok(())
}</t>
<t tx="vitalije.20190721200842.1">pub fn get_all_at(conn: &amp;Connection, tstamp: &amp;str) -&gt; Result&lt;String&gt; {
    let mut nodes = HashMap::new();
    {
        let mut stmt = conn.prepare("select gnx, hb from present where not x")?;
        let mut rows = stmt.query(NO_PARAMS)?;
        while let Some(row) = rows.next()? {
            let gnx: String = row.get(0)?;
            let hb: String = row.get(1)?;
            nodes.insert(gnx, hb);
        }
    }
    {
        let mut stmt = conn.prepare("select gnx, d from changes where t &gt;= ? order by t desc")?;
        let mut rows = stmt.query(params![tstamp])?;
        while let Some(row) = rows.next()? {
            let gnx: String = row.get(0)?;
            let d: Vec&lt;u8&gt; = row.get(1)?;
            if let Some(b) = nodes.get_mut(&amp;gnx) {
                let x = deltainv(&amp;b, &amp;d);
                *b = String::from_utf8(x).expect("deltainv must produce utf8");
            }
        }
    }
    let mut o = nodes.remove("__outline__").unwrap();
    o.push('\n');
    o.push('\n');
    for (gnx, hb) in nodes.iter() {
        let n = gnx.len() + hb.len() + 1;
        o.push_str(&amp;format!("{} {}\n{}", n, &amp;gnx, &amp;hb));
    }
    Ok(o)
}</t>
<t tx="vitalije.20190721203545.1">pub fn get_node_rev_count(conn: &amp;Connection, gnx: &amp;str) -&gt; Result&lt;(String, String, u32)&gt; {
    let mut stmt = conn.prepare(
        "select Coalesce(min(t), strftime('now')), 
              Coalesce(max(t), strftime('now')),
              count(t) from changes where gnx=?",
    )?;
    let mut rows = stmt.query(params![gnx])?;
    if let Some(row) = rows.next()? {
        let n: u32 = row.get(2)?;
        let t1: String = row.get(0)?;
        let t2: String = row.get(1)?;
        Ok((t1, t2, n))
    } else {
        Ok((String::new(), String::new(), 0))
    }
}
</t>
<t tx="vitalije.20190721205405.1">pub fn get_node_at(conn: &amp;Connection, gnx: &amp;str, tstamp: &amp;str) -&gt; Result&lt;String&gt; {
    let mut stmt = conn.prepare("select hb from present where gnx = ?")?;
    let mut rows = stmt.query(params![gnx])?;
    let mut hb = if let Some(row) = rows.next()? {
        row.get(0)?
    } else {
        String::new()
    };
    let mut stmt = conn.prepare("select t, d from changes where gnx=? order by t desc")?;
    let mut rows = stmt.query(params![gnx])?;
    while let Some(row) = rows.next()? {
        let t: String = row.get(0)?;
        if t.as_str() &lt; tstamp {
            return Ok(hb);
        }
        let d: Vec&lt;u8&gt; = row.get(1)?;
        hb = String::from_utf8(deltainv(&amp;hb, &amp;d))
            .expect("deltainv must produce utf8");
    }
    Ok(hb)
}</t>
<t tx="vitalije.20190721210327.1">pub fn get_node_revision(conn: &amp;Connection, gnx: &amp;str, num: usize) -&gt; Result&lt;String&gt; {
    let mut stmt =
        conn.prepare("select hb, datetime('now', 'localtime') from present where gnx = ?")?;
    let mut rows = stmt.query(params![gnx])?;
    let mut tstamp = String::new();
    let mut hb = match rows.next()? {
        Some(row) =&gt; {
            let t: String = row.get(1)?;
            tstamp.push_str(&amp;t[..10]);
            tstamp.push('T');
            tstamp.push_str(&amp;t[11..]);
            tstamp.push_str(".000000");
            row.get(0)?
        }
        _ =&gt; String::new(),
    };
    if num == 0 {
        tstamp.push('\n');
        tstamp.push_str(&amp;hb);
        return Ok(tstamp);
    }
    let mut stmt = conn.prepare("select d,t from changes where gnx=? order by t desc")?;
    let mut rows = stmt.query(params![gnx])?;

    let mut i = num;
    while let Some(row) = rows.next()? {
        let d: Vec&lt;u8&gt; = row.get(0)?;
        hb = String::from_utf8(deltainv(&amp;hb, &amp;d))
                .expect("deltainv must produce utf8");
        i -= 1;
        if i == 0 {
            tstamp = row.get(1)?;
            break;
        }
    }
    tstamp.push('\n');
    tstamp.push_str(&amp;hb);
    Ok(tstamp)
}
</t>
<t tx="vitalije.20190721210558.1">pub fn get_all_revision(conn: &amp;Connection, rev: usize) -&gt; Result&lt;String&gt; {
    let mut nodes = HashMap::new();
    {
        let mut stmt = conn.prepare("select gnx, hb from present where not x")?;
        let mut rows = stmt.query(NO_PARAMS)?;
        while let Some(row) = rows.next()? {
            let gnx: String = row.get(0)?;
            let hb: String = row.get(1)?;
            nodes.insert(gnx, hb);
        }
    }
    let mut tstamp = String::new();
    if rev &gt; 0 {
        let mut stmt = conn.prepare("select gnx, d, t from changes order by t desc")?;
        let mut rows = stmt.query(NO_PARAMS)?;
        let mut i = 0;
        while let Some(row) = rows.next()? {
            let gnx: String = row.get(0)?;
            let d: Vec&lt;u8&gt; = row.get(1)?;
            if let Some(b) = nodes.get_mut(&amp;gnx) {
                let x = deltainv(&amp;b, &amp;d);
                *b = String::from_utf8(x).expect("deltainv must produce utf8");
            }
            i += 1;
            if i == rev {
                tstamp = row.get(2)?;
                break;
            }
        }
    }
    let mut o = nodes.remove("__outline__").unwrap();
    o.insert(0, '\n');
    o.insert_str(0, &amp;tstamp);
    o.push('\n');
    o.push('\n');
    for (gnx, hb) in nodes.iter() {
        let n = gnx.len() + hb.len() + 1;
        o.push_str(&amp;format!("{} {}\n{}", n, &amp;gnx, &amp;hb));
    }
    Ok(o)
}</t>
<t tx="vitalije.20190722071704.1">fn dbname(a: &amp;str) -&gt; String {
    let mut res = String::from(a);
    res.push_str(".history");
    res
}
</t>
<t tx="vitalije.20190722071708.1">fn make_connection(fname: &amp;str) -&gt; db::Connection {
    db::connect(&amp;dbname(fname)).unwrap()
}
</t>
<t tx="vitalije.20190722072026.1">fn ensure_connection(hmap: &amp;mut ConMap, fname: &amp;str) {
    if !hmap.contains_key(fname) {
        let conn = make_connection(fname);
        hmap.insert(String::from(fname), conn);
    }
}
</t>
<t tx="vitalije.20190722080218.1">fn post_node_at(data: web::Data&lt;AppState&gt;, text: String) -&gt; HttpResponse {
    let (fname, _, rest) = partition(&amp;text, "\n");
    let (gnx, _, tstamp) = partition(rest, " ");

    let mut hmap = data.m.borrow_mut();
    if data.valid_names.lines().all(|x| x != fname) {
        return HttpResponse::NotFound()
            .header("x-err", format!("Unknown file:[{}]", fname))
            .finish();
    }
    ensure_connection(&amp;mut hmap, fname);

    match db::get_node_at(hmap.get_mut(fname).unwrap(), gnx, tstamp) {
        Ok(s) =&gt; HttpResponse::Ok().content_type("text/plain").body(s),
        Err(e) =&gt; {
            println!("Failed node {}\n{} at {}\n {:?}", fname, gnx, tstamp, e);
            HttpResponse::NotFound()
                .header("x-err", format!("Error: {:?}", e))
                .finish()
        }
    }
}
</t>
<t tx="vitalije.20190722080222.1">fn post_snapshot_at(data: web::Data&lt;AppState&gt;, text: String) -&gt; HttpResponse {
    let (fname, _, tstamp) = partition(&amp;text, "\n");
    let mut hmap = data.m.borrow_mut();
    if data.valid_names.lines().all(|x| x != fname) {
        return HttpResponse::NotFound().body("Unknown file");
    }
    ensure_connection(&amp;mut hmap, fname);
    match db::get_all_at(hmap.get_mut(fname).unwrap(), tstamp) {
        Ok(s) =&gt; HttpResponse::Ok().content_type("text/plain").body(s),
        Err(e) =&gt; {
            println!("Failed snapshot {} at {}\n {:?}", fname, tstamp, e);
            HttpResponse::NotFound().body(format!("\n\nError: {:?}", e))
        }
    }
}
</t>
<t tx="vitalije.20190722080236.1">fn post_node_rev(data: web::Data&lt;AppState&gt;, text: String) -&gt; HttpResponse {
    let (fname, _, rest) = partition(&amp;text, "\n");
    let (gnx, _, num) = partition(rest, " ");
    let num: usize = match num.trim().parse() {
        Ok(i) =&gt; i,
        _ =&gt; return HttpResponse::BadRequest().body(format!("Bad request: {:?}", num)),
    };
    let mut hmap = data.m.borrow_mut();
    if data.valid_names.lines().all(|x| x != fname) {
        return HttpResponse::NotFound()
            .header("x-err", format!("Unknown file:[{}]", fname))
            .finish();
    }
    ensure_connection(&amp;mut hmap, fname);
    match db::get_node_revision(hmap.get_mut(fname).unwrap(), gnx, num) {
        Ok(s) =&gt; HttpResponse::Ok().content_type("text/plain").body(s),
        Err(e) =&gt; {
            println!("Failed node {}\n{} rev {}\n {:?}", fname, gnx, num, e);
            HttpResponse::NotFound()
                .header("x-err", format!("Error: {:?}", e))
                .finish()
        }
    }
}
</t>
<t tx="vitalije.20190722080629.1">#[derive(Serialize)]
struct RevCount {
    tmin: String,
    tmax: String,
    n: u32,
}
fn post_node_rev_count(data: web::Data&lt;AppState&gt;, text: String) -&gt; HttpResponse {
    let (fname, _, gnx) = partition(&amp;text, "\n");
    let mut hmap = data.m.borrow_mut();
    if data.valid_names.lines().all(|x| x != fname) {
        return HttpResponse::NotFound().body("Unknown file");
    }
    ensure_connection(&amp;mut hmap, fname);
    match db::get_node_rev_count(hmap.get_mut(fname).unwrap(), gnx) {
        Ok((tmin, tmax, n)) =&gt; HttpResponse::Ok().json(RevCount { tmin, tmax, n }),
        Err(e) =&gt; {
            println!("Failed node rev count {}\n{}\n {:?}", fname, gnx, e);
            HttpResponse::NotFound().body(format!("\n\nError: {:?}", e))
        }
    }
}
</t>
<t tx="vitalije.20190722081531.1">fn post_snapshot_rev(data: web::Data&lt;AppState&gt;, text: String) -&gt; HttpResponse {
    let (fname, _, rest) = partition(&amp;text, "\n");
    let num: usize = match rest.trim().parse() {
        Ok(i) =&gt; i,
        _ =&gt; return HttpResponse::BadRequest().body("Bad request"),
    };
    let mut hmap = data.m.borrow_mut();
    if data.valid_names.lines().all(|x| x != fname) {
        return HttpResponse::NotFound().body("Unknown file");
    }
    ensure_connection(&amp;mut hmap, fname);
    match db::get_all_revision(hmap.get_mut(fname).unwrap(), num) {
        Ok(s) =&gt; HttpResponse::Ok().content_type("text/plain").body(s),
        Err(e) =&gt; {
            println!("Failed snapshot {} rev {}\n {:?}", fname, num, e);
            HttpResponse::NotFound().body(format!("\n\nError: {:?}", e))
        }
    }
}
</t>
<t tx="vitalije.20190722085141.2">def genbulma(x):
    ob = {}
    ob['data'] = x
    ob['outputStyle'] = 'compressed'
    resp = requests.post('http://localhost:8011/bulma/sass/', json.dumps(ob).encode('utf8'))
    if resp.status_code == 200:
        return resp.text
    else:
        g.es('bulma error\n', resp.text)</t>
<t tx="vitalije.20190722085141.3">def genpug(x):
    ob = {}
    ob['data'] = x
    ob['env'] = {}
    ob['files'] = {}
    resp = requests.post('http://localhost:8011/pug/', json.dumps(ob).encode('utf8'))
    if resp.status_code == 200:
        return resp.text
    else:
        g.es('pug error\n', resp.text)</t>
<t tx="vitalije.20190722085141.4">def process_one(p, gen):
    gnx = p.gnx
    x = at.stringToString(p, p.b, sentinels=False)
    if c.user_dict.get(gnx) == x:
        # g.es('unchaned', p.h)
        return
    fromdb = lambda x:c.db[x.group(1)]
    x2 = re.sub('__from_db__([^_]+)__', fromdb, x)
    y = gen(x2)
    if y:
        c.user_dict[gnx] = x
        fname = g.os_path_join(c.getNodePath(p), p.h.split(' ', 1)[1].strip())
        with open(fname, 'wt', encoding='utf8') as out:
            out.write(y)
            g.es('%s generated %d bytes'%(p.h, len(y.encode('utf8'))))</t>
<t tx="vitalije.20190722085141.5">def genvendor(x):
    b = []
    for line in x.split('\n'):
        s = line.strip()
        if not s:continue
        b.append(c.db[s])
    return '\n'.join(b)</t>
<t tx="vitalije.20190722085141.6">def gencoffee(x):
    r = requests.post('http://localhost:8011/coffee/', x.encode('utf8'))
    if r.status_code == 200:
        n = int(r.headers.get('js-length'))
        return r._content[:n].decode('utf8')
    else:
        g.es('coffee error\n', r.text)</t>
<t tx="vitalije.20190722085236.1">def clean_uas_and_save_ref():
    for v in c.fileCommands.gnxDict.values():
        if not hasattr(v, 'unknownAttributes'): continue
        if not v:
            del v.unknownAttributes
            continue
        if tuple(v.u.keys()) == ('icons',):
            del v.unknownAttributes
            continue
    c.fileCommands.save_ref()
    c.frame.tree.declutter_update = True</t>
<t tx="vitalije.20190722085656.1">def ensure_target_web():
    if os.path.exists('leo-ver-serv/web'): return
    os.makedirs('leo-ver-serv/web/js')
    os.makedirs('leo-ver-serv/web/css/img')
</t>
<t tx="vitalije.20190722085734.1">@path leo-ver-serv/web
g.os.chdir(c.openDirectory)
g.es(g.os.getcwd())
for p1 in p.children():
    g.es(c.getNodePath(p1))
</t>
<t tx="vitalije.20190722085751.1">@language coffeescript
@tabwidth -2
$el = (_id) -&gt; document.getElementById(_id)
$q = (q) -&gt; document.querySelector(q)
$qall = (q) -&gt; document.querySelectorAll(q)
@others
window.addEventListener 'load', start_app

</t>
<t tx="vitalije.20190722085820.1">kefir-prod
codemirror-js
codemirror-mode-simple
codemirror-mode-python
codemirror-mode-coffeescript
codemirror-mode-rust</t>
<t tx="vitalije.20190722085839.1">/* @import "bulma.sass"; */
@others
/* __from_db__bulma-tooltip__ */
__from_db__codemirror-css__
__from_db__codemirror-theme-abcdef__
body {
    margin:0;padding:0;
}
#progress {
    position: fixed;
    bottom: 0px;
    left: 0px;
    width: 100%;
}

span.icon &gt; svg.svgicon {
    display: inline-block;
    width: 1em;
    height: 1em;
    vertical-align:-.125em;
}
#app {
    display:flex;
    flex-direction: column;
    flex-grow:1;
    flex:auto;
}
#toolbar {
    width:100%;
    flex-grow:0;
    height:64px;
    background:#ccccbb;
    display:flex;
    flex-direction: row;
    align-items: center;
}
#toolbar label {
    width: 10em;
    text-align: right;
}
#toolbar input[type=range] {
    width: 400px;
    margin-right: 20px;
}
#tree {width: 400px;height:100%}
.CodeMirror { height: 100%;}</t>
<t tx="vitalije.20190722085852.1">@tabwidth -2
&lt;&lt;mixins&gt;&gt;
doctype html
html
  head
    meta(charset="utf-8")
    meta(name="viewport",content="width=device-width, initial-scale=1")
    title Leo history browser
    link(rel='stylesheet', href='css/app.css')
    link(rel='Shortcut Icon', href='/favicon.ico')
  body
    #toolbar
      label
        | Outline version[
        span#orev latest
        | ]:
      input#outline-revs(type="range", min="0", max="100", value="100")
      label
        | Node version[
        span#nrev latest
        | ]:
      input#node-revs(type="range", min="0", max="100", value="100")
      label Leo file:
      select#leo-files
    .app-flex
      canvas#tree
      #app
        textarea#body
    #mytemplates(style='display:none')
      @others
    progress#progress.progress.is-primary.no-show(value="100", max="100") 100%
    script(type="text/javascript", src="js/vendors.js")
    script(type="text/javascript", src="js/app.js")

</t>
<t tx="vitalije.20190722085928.1">import requests
import io
import zipfile
@others
@
s = requests.get('https://kefirjs.github.io/kefir/dist/kefir.js').text
c.db['kefir-dev'] = s
s = requests.get('https://kefirjs.github.io/kefir/dist/kefir.min.js').text
c.db['kefir-prod'] = s
s = requests.get('https://use.fontawesome.com/releases/v5.3.1/js/all.js').text
c.db['fontawesome'] = s
s = requests.get('https://pixijs.download/release/pixi.min.js').text
c.db['pixi'] = s
s = requests.get('https://github.com/pixijs/pixi-filters/releases/download/v2.7.1/pixi-filters.js').text
c.db['pixi-filters'] = s
s = requests.get('https://raw.githubusercontent.com/Wikiki/bulma-tooltip/master/dist/css/bulma-tooltip.min.css').text
c.db['bulma-tooltip'] = s
s = requests.get('https://codemirror.net/codemirror.zip').content
c.db['codemirrorzip'] = s
@c
extract_codemirror()
g.es('ok')
</t>
<t tx="vitalije.20190722090008.1"></t>
<t tx="vitalije.20190722094440.1">def extract_codemirror():
    s = c.db['codemirrorzip']
    zf = zipfile.ZipFile(io.BytesIO(s), 'r')
    nlist = zf.namelist()
    cmfiles = {
        'lib/codemirror.css': 'codemirror-css',
        'lib/codemirror.js': 'codemirror-js',
        'theme/abcdef.css': 'codemirror-theme-abcdef',
        'mode/python/python.js': 'codemirror-mode-python',
        'mode/rust/rust.js': 'codemirror-mode-rust',
        'mode/coffeescript/coffeescript.js': 'codemirror-mode-coffeescript',
        'addon/mode/simple.js': 'codemirror-mode-simple'
    }
    ew = tuple(cmfiles.keys())
    for n in nlist:
        if n.endswith(ew):
            for k in ew:
                if n.endswith(k):
                    v = cmfiles[k]
                    c.db[v] = zf.read(n).decode('utf8')
                    break</t>
<t tx="vitalije.20190722101835.1">.app-flex {
    display:flex;
    flex-direction:row;
    flex-wrap:1;
}</t>
<t tx="vitalije.20190722102031.1">.no-show { display: none !important;}</t>
<t tx="vitalije.20190722122040.1">appstate = {
}
do -&gt;
  ss = {
    fi: 0
    leoFiles:[]
    range: {
      tmin:'0',
      tmax:'0',
      n: 0,
      i: 0
    }
    nodeRange: {
      tmin:'0',
      tmax:'0',
      n: 0,
      i: 0
    }
    outline:[]
    topIndex: 0
    currentIndex:-1
  }
  Object.defineProperties appstate,
    @others

window._state = appstate</t>
<t tx="vitalije.20190722124223.1">leoFiles:
  get: -&gt; ss.leoFiles
  set: (v) -&gt;
    ss.leoFiles.splice(0, ss.leoFiles.length, ...v)
    docdispatch EVENTS.LEOFILES_CHANGED, v
</t>
<t tx="vitalije.20190722124256.1">currentFile:
  get: -&gt; ss.leoFiles[ss.fi]
  set: (v) -&gt;
    ss.fi = ss.leoFiles.indexOf(v)
    docdispatch EVENTS.LEO_FILE_SELECTED, v
currentFileIndex:
  get: -&gt; ss.fi
  set: (v) -&gt;
    ss.fi = v
    docdispatch EVENTS.LEO_FILE_SELECTED, ss.leoFiles[v]</t>
<t tx="vitalije.20190722124355.1">range:
  get: -&gt; {...ss.range}
  set: (v) -&gt;
    ss.range.tmin = v.tmin
    ss.range.tmax = v.tmax
    ss.range.n = v.n
    if v.n &lt; ss.range.i
      ss.range.i = v.n
    v.i = ss.range.i
    docdispatch EVENTS.RANGE_CHANGED, v

nodeRange:
  get: -&gt; {...ss.nodeRange}
  set: (v) -&gt;
    ss.nodeRange.tmin = v.tmin
    ss.nodeRange.tmax = v.tmax
    ss.nodeRange.n = v.n
    if v.n &lt; ss.nodeRange.i
      ss.nodeRange.i = v.n
    v.i = ss.nodeRange.i
    docdispatch EVENTS.NODE_RANGE_CHANGED, v
</t>
<t tx="vitalije.20190722124627.1">fn get_leo_files(data: web::Data&lt;AppState&gt;) -&gt; String {
    data.valid_names.clone()
}
</t>
<t tx="vitalije.20190722130051.1">EVENTS =
  GNX_SELECTED: 'gnxselected'
  LEO_FILE_SELECTED: 'leofileselected'
  LEOFILES_CHANGED: 'leofileschanged'
  NODE_RANGE_CHANGED: 'noderangechanged'
  NODE_REV_CHANGED: 'noderevchanged'
  OUTLINE_CHANGED: 'outlinechanged'
  RANGE_CHANGED: 'rangechanged'
  REV_CHANGED: 'revchanged'
  TOPINDEX_CHANGED: 'topindexchanged'</t>
<t tx="vitalije.20190722130334.1">docdispatch = (kind, data) -&gt;
  e = new CustomEvent(kind, detail: data)
  document.dispatchEvent e

eldispatch = (el, kind, data) -&gt;
  el.dispatchEvent(new CustomEvent(kind, detail: data))</t>
<t tx="vitalije.20190722130737.1">rev:
  get: -&gt; ss.range.i
  set: (x) -&gt;
    ss.range.i = Math.min(ss.range.n, x)
    docdispatch EVENTS.REV_CHANGED, ss.range.i

nodeRev:
  get: -&gt; ss.nodeRange.i
  set: (x) -&gt;
    ss.nodeRange.i = Math.min(ss.nodeRange.n, x)
    docdispatch EVENTS.NODE_REV_CHANGED, ss.nodeRange.i</t>
<t tx="vitalije.20190722130905.1">get_rev_count = (gnx) -&gt;
  fname = appstate.currentFile
  rq =
    method: 'POST'
    body: "#{fname}\n#{gnx}"
  fetch('/node-rev-count', rq).then((x) -&gt; x.json()).then (x) -&gt;
    if gnx == '__outline__'
      appstate.range = x
    else
      appstate.nodeRange = x
</t>
<t tx="vitalije.20190722130908.1">get_leo_files = -&gt;
  fetch '/leo-files'
  .then (x) -&gt; x.text()
  .then (x) -&gt;
    appstate.leoFiles = x.split('\n')
</t>
<t tx="vitalije.20190722131709.1">outline:
  get: -&gt; ss.outline
  set: (v) -&gt;
    ss.outline.splice(0, ss.outline.length, ...v)
    if ss.topIndex &gt; v.length - 30
      ss.topIndex = Math.max(0, v.length - 30)
    docdispatch EVENTS.OUTLINE_CHANGED, v</t>
<t tx="vitalije.20190722132007.1">topIndex:
  get: -&gt; ss.topIndex
  set: (v) -&gt;
    ss.topIndex = v
    docdispatch EVENTS.TOPINDEX_CHANGED, v</t>
<t tx="vitalije.20190722132321.1">topNode:
  get: -&gt; ss.outline[ss.topIndex]</t>
<t tx="vitalije.20190722135155.1">currentIndex:
  get: -&gt; ss.currentIndex
  set: (v) -&gt;
    ss.currentIndex = v
    gnx = ss.outline[v]?.gnx
    docdispatch EVENTS.GNX_SELECTED, gnx if gnx

</t>
<t tx="vitalije.20190722135552.1">drawTree = -&gt;
  canv = $el('tree')
  w = canv.width; h = canv.height
  ctx = canv.getContext('2d')
  ctx.fillStyle = '#336699'
  ctx.fillRect(0, 0, w, h)
  ctx.font = '20px sans'
  HR = 24
  NR =  Math.floor(h / HR)
  i = appstate.topIndex
  vnodes = visible_nodes().slice(i, i + NR)
  selIndex = appstate.currentIndex
  inv = -&gt;
    ctx.fillStyle = '#ffffce'
    ctx.fillRect(0, y-20, w, HR)
    ctx.fillStyle = '#336699'
  ctx.fillStyle = '#ffffce'
  y = HR
  vnodes.forEach (vn, j) -&gt;
    if selIndex == vn.i
      inv()
    if vn.pref
      ctx.fillText(vn.pref, vn.x - 20, y)
    ctx.fillText(vn.h, vn.x, y)
    ctx.fillStyle = '#ffffce' if selIndex == vn.i
    y += HR
  ctx = null</t>
<t tx="vitalije.20190722141838.1">partition = (s, t) -&gt;
  i = s.indexOf(t)
  if i &gt; -1
    [s.slice(0, i), t, s.slice(i + t.length)]
  else
    [s, '', '']</t>
<t tx="vitalije.20190722151416.1">get_outline_rev = (rev) -&gt;
  fname = appstate.currentFile
  body = fname + '\n__outline__ ' + rev
  fetch '/node-rev',
    method: 'POST'
    body: body
  .then (x) -&gt; x.text()
  .then set_outline</t>
<t tx="vitalije.20190722151421.1">set_outline = (data) -&gt;
  outline = appstate.outline.splice(0)
  lines = data.split('\n')
  appstate.outlineTime = lines.shift()
  lines.shift()
  outline.splice lines.length
  lines.forEach (line, i) -&gt;
    node = outline[i]
    node ?=
      gnx:''
      lev: 0
      exp: false
      h: ''
      old: false
    [lev, sep, rest] = partition line, ' '
    [gnx, sep, h] = partition rest, ' '
    node.gnx = gnx
    node.lev = parseInt(lev) - 1
    node.h = h
    unless node.old
      node.old = true
      node.exp = node.lev &lt; 3
    outline[i] = node
  _visible_nodes._ver++
  appstate.outline = outline</t>
<t tx="vitalije.20190722153239.1">_visible_nodes =
  _ver: 0
  _last_ver: -1
  nodes: []
visible_nodes = -&gt;
  if _visible_nodes._last_ver == _visible_nodes._ver
    return _visible_nodes.nodes
  _visible_nodes._last_ver = _visible_nodes._ver
  nodes = []
  outline = appstate.outline
  i = 0
  N = outline.length
  while i &lt; N
    n = outline[i]
    n2 = outline[i + 1]
    hasChildren = n2 and n2.lev &gt; n.lev
    if hasChildren
      pref = if n.exp then  '▼' else '▶'
    else
      pref = false
    nodes.push
      i: i
      gnx: n.gnx
      h: n.h
      pref: pref
      x: n.lev * 36 + 28
    i += 1
    if hasChildren and not n.exp
      while n2 and n2.lev &gt; n.lev
        i += 1
        n2 = outline[i]
  _visible_nodes.nodes = nodes
  nodes</t>
<t tx="vitalije.20190722171734.1">get_body = (e) -&gt;
  gnx = e.detail
  rq =
    method: 'POST'
    body: appstate.currentFile + '\n' + gnx + ' ' + appstate.outlineTime
  fetch '/node-at', rq
  .then (x) -&gt; x.text()
  .then (x) -&gt;
    _cm.setValue(x)
    get_rev_count(gnx)

</t>
<t tx="vitalije.20190722172447.1">start_app = -&gt;
  h = window.innerHeight - $el('toolbar').getBoundingClientRect().height
  $q('.app-flex').style.height = "#{h}px"
  install_editor()
  connect_file_selection()
  connect_tree(h)
  connect_outline_revisions()
  connect_node_revisions()
  get_leo_files().then -&gt;
    get_rev_count('__outline__')
  wait(20).then -&gt;
    appstate.rev = 0
  last_redraw = [0]
  rf = (t) -&gt;
    if last_redraw[0] != 0
      dt = t - last_redraw[0]
      if dt &gt; 10000
        # if the page was not visible for more than 10s
        # we must repopulate ranges. This will happen
        # automatically after the following line
        appstate.currentFileIndex = appstate.currentFileIndex
    last_redraw[0] = t
    requestAnimationFrame(rf)
  requestAnimationFrame(rf)</t>
<t tx="vitalije.20190729154326.1">wait = (t) -&gt;
  new Promise (res, rej) -&gt;
    setTimeout res, t</t>
<t tx="vitalije.20190729171345.1">get_body_rev = (gnx, rev) -&gt;
  rq =
    method: 'POST'
    body: appstate.currentFile + '\n' + gnx + ' ' + appstate.nodeRev
  fetch '/node-rev', rq
  .then (x) -&gt; x.text()
  .then (x) -&gt;
    x = partition(x, '\n')[2]
    _cm.setValue(x)</t>
<t tx="vitalije.20190729172726.1">connect_outline_revisions = -&gt;
  orevinp = $el('outline-revs')
  orevspan = $el('orev')
  Kefir.fromEvents(orevinp, 'input').onValue -&gt;
    v = parseInt(orevinp.value)
    n = appstate.range.n
    if v == n
      orevspan.innerText = 'latest'
    else
      orevspan.innerText = (v - n).toString()
    i = n - v
    appstate.rev = i
  document.addEventListener EVENTS.RANGE_CHANGED, (e) -&gt;
    r = e.detail
    orevinp.max = r.n
    orevinp.value = r.n - r.i
    appstate.rev = r.i

  document.addEventListener EVENTS.REV_CHANGED, (ev) -&gt; get_outline_rev(ev.detail)
</t>
<t tx="vitalije.20190729172738.1">connect_node_revisions = -&gt;
  nrevinp = $el('node-revs')
  nrevspan = $el('nrev')
  Kefir.fromEvents(nrevinp, 'input').onValue -&gt;
    v = parseInt(nrevinp.value)
    r = appstate.nodeRange
    n = r.n
    if v == n
      nrevspan.innerText = 'latest'
    else
      nrevspan.innerText = (v - n).toString()
    i = n - v
    appstate.nodeRev = i
  document.addEventListener EVENTS.NODE_RANGE_CHANGED, (e) -&gt;
    r = e.detail
    nrevinp.max = r.n
    nrevinp.value = r.n - r.i
    appstate.nodeRev = r.i

  document.addEventListener EVENTS.NODE_REV_CHANGED, (ev) -&gt;
    gnx = appstate.currentGnx
    get_body_rev(gnx, ev.detail)
</t>
<t tx="vitalije.20190729173243.1">currentGnx:
  get: -&gt;
    i = ss.currentIndex
    ss.outline[i]?.gnx</t>
<t tx="vitalije.20190729173544.1">partition = (s, sep) -&gt;
  i = s.indexOf(sep)
  if i &lt; 0
    return [s, '', '']
  [s.slice(0, i), sep, s.slice(i + sep.length)]

rpartition = (s, sep) -&gt;
  i = s.lastIndexOf(sep)
  if i &lt; 0
    return [s, '', '']
  [s.slice(0, i), sep, s.slice(i + sep.length)]</t>
<t tx="vitalije.20190730145718.1"># Leo version server

`leo-ver-serv` is a web server which accepts POST requests from Leo. Leo sends snapshots
of its current state, server calculates delta between the previous version of snapshot and
the current one, and stores delta in a database. Server also serves a small web application
which allows user to browse history of known Leo files.

## Installation

If you already have installed `cargo` and `rustc`, it is enaugh to execute the following
command:

```
cargo install leo-ver-serv
```

It requires one or two arguments. The first one is a file containing known Leo files, and
the second argument optionally is a port number on which server should listen.

```
leo-ver-serv ~/.leo/.leoRecentFiles.txt 8088
```

## Leo Configuration
In Leo open _myLeoSettings.leo_ add a node under `@settings` with matching port:

```
@int history-tracer-port=8088
```
...and ensure `history_tracer.py` in body of `@settings--&gt;@enabled-plugins` is uncommented.

</t>
<t tx="vitalije.20190920125620.1">    #[allow(dead_code)]
    static BUG002_A:&amp;str = r#"from student import moja_tajna_funkcija

def check(a, b):
    assert moja_tajna_funkcija(a, b) == a + b, "Функција не даје добар резултат за аргументе: %r и %r"%(a, b)

if __name__ == '__main__':
    for x in range(-100, 101):
        for y in range(-100, 101):
            check(x, y)
    print("Функција ради коректно")"#;

    #[allow(dead_code)]
    static BUG002_B:&amp;str = r#"from student import moja_tajna_funkcija

def check(a, b):
    assert moja_tajna_funkcija(a, b) == a + b, "Функција не даје добар резултат за аргументе: %r и %r"%(a, b)

if __name__ == '__main__':
    for x in range(-100, 101):
        for y in range(-100, 101):
            check(x, y)
    print("Није пронађена грешка у твом програму.")"#;
</t>
<t tx="vitalije.20190920132731.1">#[test]
fn test_bug_002() {
    let a="from student import moja_tajna_funkcija\n\ndef check(a, b):\n    assert moja_tajna_funkcija(a, b) == a + b, \"Функција не даје добар резултат за аргументе: %r и %r\"%(a, b)\n\nif __name__ == '__main__':\n    for x in range(-100, 101):\n        for y in range(-100, 101):\n            check(x, y)\n    print(\"Функција ради коректно\")\n";
    let b="from student import moja_tajna_funkcija\n\ndef check(a, b):\n    assert moja_tajna_funkcija(a, b) == a + b, \"Функција не даје добар резултат за аргументе: %r и %r\"%(a, b)\n\nif __name__ == '__main__':\n    for x in range(-100, 101):\n        for y in range(-100, 101):\n            check(x, y)\n    print(\"Није пронађена грешка у твом програму.\")\n";
    let d = delta(&amp;b, &amp;a);
    let mut d1 = Vec::new();
    d1.extend_from_slice(b"6P\n5H@0,18:\x9d\xd0\xb8\xd1\x98\xd0\xb5 \xd0\xbf\xd1\x80\xd0\xbe\xd0\xbd\xd0\xb0\xd1\x92\xd0\xb5\xd0\xbd\xd0\xb0 \xd0\xb3\xd1\x80\xd0\xb5\xd1\x88\xd0\xba\xd0\xb0 \xd1\x83 \xd1\x82\xd0\xb2\xd0\xbe\xd0\xbc \xd0\xbf\xd1\x80\xd0\xbe\xd0\xb3\xd1\x80\xd0\xb0\xd0\xbc\xd1\x83.\")\n2mdlCq;");
    assert_eq!(d, d1);
}
</t>
<t tx="vitalije.20190928104916.1">connect_tree = (h) -&gt;
  canv = $el('tree')
  canv.height = h
  canv.width = 400
  ctx = canv.getContext('2d')
  ctx.fillStyle = '#336699'
  ctx.fillRect(0, 0, 400, h)
  Kefir.fromEvents(canv, 'mousedown').onValue (e) -&gt;
    HR = 24
    r = canv.getBoundingClientRect()
    x = e.x - r.left
    y = e.y - r.top
    vnodes = visible_nodes().slice(appstate.topIndex)
    vn = vnodes[Math.floor(y / HR)]
    return unless vn
    if x &lt; vn.x and vn.pref
      node = appstate.outline[vn.i]
      node.exp = not node.exp
      _visible_nodes._ver++
    appstate.currentIndex = vn.i

  document.addEventListener EVENTS.OUTLINE_CHANGED, drawTree
  document.addEventListener EVENTS.TOPINDEX_CHANGED, drawTree
  document.addEventListener EVENTS.TOPINDEX_CHANGED, drawTree
  document.addEventListener EVENTS.GNX_SELECTED, drawTree
  document.addEventListener EVENTS.GNX_SELECTED, get_body

</t>
<t tx="vitalije.20190928112512.1">connect_file_selection = -&gt;
  s = $el('leo-files')
  Kefir.fromEvents(s, 'change').onValue -&gt;
    appstate.currentFileIndex = s.selectedIndex
  document.addEventListener EVENTS.LEO_FILE_SELECTED, select_leo_file
  document.addEventListener EVENTS.LEOFILES_CHANGED, update_leo_files
</t>
<t tx="vitalije.20190928151310.1">update_leo_files = -&gt;
  s = $el('leo-files')
  mkopt = (f, i) -&gt;
    x = document.createElement('option')
    x.value = i
    x.innerText = rpartition(f, '/')[2]
    x
  lfs = appstate.leoFiles
  lfs.forEach (f, i) -&gt;
    if i &gt;= s.options.length
      s.options.add(mkopt(f, i))
    else
      s.options[i].value = i
      s.options[i].innerText = rpartition(f, '/')[2]
  while s.options.length &gt; lfs.length
    s.options.remove(lfs.length)</t>
<t tx="vitalije.20190928151405.1">install_editor = -&gt;
  window._cm = CodeMirror.fromTextArea $el('body'),
    lineNumbers: true
    theme: 'abcdef'</t>
<t tx="vitalije.20190928151539.1">select_leo_file = -&gt;
  console.log appstate.currentFile, 'selected'
  return unless appstate.currentFile
  get_rev_count('__outline__')
  .then -&gt;
    _visible_nodes._ver++
    appstate.currentIndex = Math.min(appstate.currentIndex, visible_nodes().length - 1)
    appstate.rev = 0</t>
<t tx="vitalije.20190928170916.1">type ConMap = HashMap&lt;String, db::Connection&gt;;

struct AppState {
    m: RefCell&lt;ConMap&gt;,
    valid_names: String,
}
impl AppState {
    fn new() -&gt; Self {
        let mut args = env::args();
        let valid_names = load_valid_names(&amp;args.nth(1).unwrap());
        AppState {
            m: RefCell::new(HashMap::new()),
            valid_names,
        }
    }
}
</t>
<t tx="vitalije.20190928170928.1">fn load_file(fname: &amp;str) -&gt; std::io::Result&lt;String&gt; {
    let mut content = String::new();
    let mut file = File::open(fname)?;
    file.read_to_string(&amp;mut content)?;
    Ok(content)
}
</t>
<t tx="vitalije.20190928170932.1">fn load_valid_names(fname: &amp;str) -&gt; String {
    match load_file(fname) {
        Ok(mut s) =&gt; {
            s.retain(|c|c != '\r');
            s
        },
        Err(e) =&gt; {
            println!("Can't load valid file names: {:?}", e);
            String::new()
        }
    }
}
</t>
</tnodes>
</leo_file>
